# JavaLearningProject
This is my Java beginners notes.

这是本人在自学java时做的笔记，这个笔记的主体是毕向东老师的课程内容。
《毕向东课程笔记》
                           ——杨
***配置java的环境变量***
***第一个程序HelloWorld***
【2016.7.8】
java关键字（）
1.特定含义的词
2.所有小写

java标识符
1.自定义的名称
2.字母大小写，0-9，_$组成
3.不能数字开头，不能使用关键字 
4.严格区分大小写

java名称规范
1.包名：小写
2.类名，接口名：多单词时，首字母大写
3.变量名和函数名：多单词，第一个单词首字母小写，第二个单词开始首字母大写
4.常量名：所有字母大写，多单词，每个单词下划线连接

注释
/**
这是一个文档注释，一般放在文档最前，用于写项目需求或者项目概述，对于项目一个简单的步骤构想
*/
/*
这是一个多行注释，只要在起始符和停止符之间的内容都会被注释掉
*/
//这是一个单行注释，单行注释可写在语句后，也可以独占一行以示说明
注释在使用时，可以解释项目中的语句意思，以及对变量的说明，让以后便于修改优化。
**注释不可嵌套
**在写程序时，建议先写文档注释写需求，不要急着写程序敲代码。
**没有思想和需求永远写不出好的程序

常量变量
1.整数常量：所有整数
2.小数常量：所有小数
3.布尔常量：特有，两个，true，false
4.字符常量：将一个字母，数字或者符号以（' '）标识，只能存放一个字符
5.字符串常量：将一个或者多个字符以双引号标识（"hello word"）
6.null常量：null

整数，java的四种表现形式
十进制，0-9，满10进1 
二进制  0，1，满2进1 
八进制，0-7，满8进1，用0开头
十六进制，0-9，A-F，满16进1，用0x开头

【2016.7.9】
进制的特点：
计算机中存储的数据都是以二进制形式存储的，一个整数是由4个字节组成，而一个字节又由8个单位组成，所以计算机底层的二进制数由32个位组成。
二进制（0，1的不同排列）
一个字节由八个单位组成
进制越大，表现形式越短
十进制-->二进制
原理：对十进制数进行除二运算
二进制-->十进制
原理：二进制乘以2的过程
负数二进制的表现形式
6==》110
-6==》6的二进制的1变成0，0变成1.
***进制转换详解（点击查看）***
【2016.7.12】
变量：就是将不确定的数据进行存储。也就是需要在内存中开辟一个空间。
如何开辟空间？
通过明确的数据类型,变量名称数据
*数据类型
1.基本数据类型
-数值型
/整数类型（byte,short,int,long）
/浮点型（float,double）
-字符类型（char)
-布尔型（boolean）
2.引用数据类型
-类（class）
-接口（interface）
-数组（[])

类型转换
例：byte b = 3
b = b +2
b+2赋值给b时提升类型后再赋值，损失精度，编译错误
*自动类型提升，小向大提升类型
*强制类型转换，b = (byte) (b +2)
都会损失精度
char也支持运算。ASCII码不同数字表示相应字符

算术运算符
+    正号/连接号   字符串数据和任何数据使用+都是相连接，最终都会变成字符串。
+    负号
+    加
-      减
*    乘
/    除
%    取模（余数）   取模时左边小于右边等于左边
++        自增1        a++-->a=a+1   b=a++(a先赋值b，a再自增)      b=++a（a先自增，再赋值给b）
--        自减1        （同上）

转义字符：
通过\来转变后面字母或者符号的含义。
\n：换行
\b：退格
\r：按下回车
\t：制表符，相当于tab键
System.out,println("\"HelloWorld"\")输出："HelloWorld"
System.out,println("\\HelloWorld\\")输出：\HelloWorld\

赋值运算符
+=        x+=4(一次运算)-->x=x+4(两次运算且有类型转换，容易损失精度)
-=        同上理
*=        同上理
/=        同上理
%=    同上理

比较运算符（true/false）
==        等等于
!=        不等于
<        小于
>        大于
<=        小于等于
>=        大于等于

逻辑运算符(用于连接boolean类型的表达式)
&        与        两边的boolean表达式结果，有一个为false，结果就是false，只有两边都为true，结果为true
|        或        两边只要有一个为true，结果为true。只有两边都有false，结果为false
^        异或    两边相同结果是false，两边不同结果是true
!        非
&和&&的特点
&无论左边是真是假，右边都运算，&&当左边为false时，右边不运算

位运算（二进制运算）：
位运算是高效率运算，二进制运算
<<        左移    3<<2  --> 3*2² -->  12  其实就是乘以2的移动的位数次幂
>>        右移      6>>2  -->6/2² -->  1其实就是除以2的移动的位数次幂

位运算在进制转换中的使用：
因为位运算在计算机的底层是二进制的运算，所以，其运算的流程如下（以左移为例，右移同理）：

位运算获取一个数的十六进制表现形式（以60为例）：
思想：
1.先将一个十进制转换为二进制，获取二进制表现形式(计算机底层的运算)，
2.因为二进制转换为十六进制的原理是取四合一，也就是说，每四个单位的二进制数则表示一位十  六进制数，
3.那么我们则用一个最后四位都为1的二进制数（1111--》15（十进制）） & 上这个要求的二进制  数，但是都是二进制数，就不必再用复杂的表达，直接用十进制相&（60&15=12），
4.第一次 & 得的结果（也就是取到了所求数二进制的最后四位）为所求数的十六进制位的最后一位（1100--》12--》c），
5.然后将所求数的二进制数 >>（右移）四位，定义一个变量（temp）来记录这个右移后的值（temp  = 60>>4），底层运算中去掉已经取走的最后四位，在空出来的前四位补上0，再进行 & 操作  （temp & 15=3），从而取得二进制的倒数第二组四位，而这则是十六进制的倒数第二位(11--》3-  -》3)，
6.以此类推，直到取完所有的 8 组四位为止。最后所得结果反向输出，60--》1100--》3c
7.过程图：

--end--
【2016.7.13】
程序流程控制：
判断结构
if语句：（关键字：if、 else）
1.if(条件表达式)
    {
             执行语句
     }
2.if(条件表达式)
    {
            执行语句1
     }
    else
    {
             执行语句2
    }
if else 结构简写格式：变量 = (条件表达式)？表达式1：表达式2;
3.if(条件表达式)
        {
            执行语句1
        }
else if(条件表达式)
        {
            执行语句2
        }
......
else
        {
            执行语句...
        }
***if语句实例***

【2016.7.20】
【选择结构】
 switch语句：（关键字：switch、case、default、break）
    switch(表达式)//表达式内只接受byet\short\int\char类型
{
    case 取值一:
    执行语句;
    break;
    case 取值二:
    执行语句;
    break;
    ……
    default:
    执行语句;
    break;//可省略此break。
}
case的选项排列顺序随意，执行顺序为先case最后default，不管排列顺序如何。如果default不在最后，则不必省略其后break
if和switch语句很像，
具体什么场景下应用哪个语句？
如果判断的具体数值不多，而是符合byet short int char这四种类型。
虽然两个语句都可以使用，建议使用switch语句。因为效率稍高。

其他情况：对区间判断，对结果为boolean类型判断，使用if，if的使用范围更广。
***switch语句实例***

【循环结构】
while语句：（关键字：while）
定义初始化表达式
while(条件表达式)
{
执行语句（循环体）
}
do whlie语句：（关键字：do while）
do
{
    执行语句（循环体）
}
while(条件表达式);
两者区别：
while：先判断条件，只有条件满足才执行循环
do while：先执行循环体，再判断条件，若条件满足，再执行循环体。也就是说，不管条件是否满足，都会至少循环一次。
***while语句实例***
for循环语句：（关键字：for）
for(初始化表达式;循环条件表达式;循环后的操作表达式)
{
    执行语句；
}
执行顺序：
初始化表达式》》1.循环条件表达式》》2.（条件不满足）执行语句》》循环后操作表达式》》1.》》2.》》……条件满足循环结束

1.for循环中所定义的变量，有自己的作用域。对于for来讲：如果将用于控制循环的增量定义在for语句中。那么该变量只在for语句内有效，for语句执行完毕。该变量在内存中消失。
2.for和while可以进行互换。如果需要定义循环增量，用for更为合适。
***for循环实例***
***for和while互换区别实例***
总结：
什么时候使用循环结构？
当要对某些语句执行很多次时，就使用循环结构

无限循环的最简单表现形式：
for(;;){ }
while(true){ }

循环注意：
一定要明确哪些语句需要参加循环，哪些不参加。

累加思想
原理：通过变量记录住循环操作后的结果.
通过循环累加。
计数器思想
原理：通过一个变量记录住数据的状态变化。
也许通过循环完成
***for循环计数器实例***
【2016.7.21】
for循环嵌套：
发现图形有很多行，每一个行有很多列
要使用嵌套循环。原理：形象说法：大圈套小圈。
例：
System.out.println("九九乘法表:");
        for (int x=1; x<=9;x++ )//被乘数
        {
            for (int y=1;y<=x;y++ )//乘数
            {
                System.out.print(y+"*"+x+"="+y*x+"\t");
            }
            System.out.println();
        }

    }
***fo嵌套循环九九乘法表实例***
***for嵌套循环等腰三角形实例***
其他流程控制语句：
break(跳出)，continue(继续)
break语句：应用范围：选择结构，循环结构
continue语句：只应用于循环结构。
1.两个语句离开应用范围，存在没有意义
2.这两个语句单独存在下面不可以有语句，因为执行不到。
3.continue语句是结束本次循环继续下一次循环。
4.标号的出现，可以让两个语句作用指定的范围。
5.可用if语句来控制两条语句的实现
标号示例：
a:for(;;)
{
   b:for(;;)
    {
       break a;//如不指定标号，默认跳出的语句是内循环
    }
}
**【函数（function）】**
1.什么是函数？
java中最小的功能单元就是函数。
函数就是定义在类中的具体有特定功能的独立小程序。
函数也称方法。
2.函数的概念分析：
1.一个运算过程，因为获取不同数据的运算结果，代码出现了重复。
2.为了提高代码的复用性，对需要重复的代码进行抽取。
3.将这部分定义（封装）为一个独立的功能。方便日后调用。
4.java中对功能的定义是通过函数的形式来体现的。
***函数的初识实例**
3.函数的格式
修饰符 返回值类型 函数名(参数类型 形式参数1,参数类型 形式参数2，……)
{
    执行语句;
    return 返回值;
}
例：
public static int getResult(int num)
{
    return num * 3+5
}
返回值类型：函数运行后的结果的数据类型。
参数类型：是形式参数的数据类型。
形式参数：是一个变量，用于存储调用函数时传递给函数的实际参数。
实际参数：传递给形式参数的具体数值。
return：用于结束函数
返回值：该值返回给调用者。
4.函数的特点：
定义函数可以将功能代码进行封装。
便于对该功能进行复用，提高代码复用性
函数只有被调用才会被执行
对于函数没有具体返回值的情况，返回值类型用关键字void表示，那么该函数的return语句如果在最后一行可以省略不写
注意：
函数中只能调用函数，不可以在函数内部定义函数。只要在类中定义就行。
定义函数时，函数的结果应该返回给调用者，交由调用者处理。
函数调用：
函数名(实际参数)
***函数的特点实例***

如何定义函数？？？（定义函数思想c++适用）
1.既然函数是一个独立的功能，那么该功能的运算结果是什么先明确
2.再明确在定义该功能的过程中是否需要未知的内容参与运算
其实这两个功能就是在明确函数的定义：
1.是在明确函数的返回值类型。
2.明确函数的参数列表（参数类型和参数个数）
end-------------------------------------
【2016.7.22】
函数的重载（overload）
在一个类中，可以存在一个以上的同名函数，只要函数的参数类型或者参数个数不同即可。就叫重载。
重载和返回值类型没关系。
什么时候用重载？
当定义的功能相同，但参与运算的位置内容不同
那么这时就定义一个函数名称以表示其功能，方便阅读，而通过参数列表的不同来区分多个同名函数。
***函数的重载实例***
***【数组】***：(关键字：new 标识：[])
概念：同一种类型数据的集合。其实数组就是一个容器
好处：可以自动给数组中的元素从0开始编号，方便操作这些元素
格式一：元素类型[] 数组名 = new 元素类型[元素个数或者数组长度]；
例：
int[] x = new int[5];//定义一个数组，数组元素个数为5，可存储5个整数
        x[0] = 666;//定义数组中0角标位元素值为666
        //x = null;如果将数组定义为null，数组为空。
        System.out.println("数组x的1角标元素值为："+x[1]);//打印数组x中的1角标位的元素值
        System.out.println("数组x的0角标元素值为："+x[0]);//打印数组x中的0角标位的元素值

格式二：元素类型[] 数组名 = new 元素类型[]{元素。元素，元素……};
示例：int[] arr = new int[]{7,3,5,9};
    int[] arr = {7,3,5,9};
***数组的创建实例***
注意：
数组在引用和操作数组时的注意事项（例）
int[] x = new int[5]
(1)x = null;
    System.out.println(x[3]);
(2)System.out.println(x[5]);
(1)NullPointerException：空指针异常；当引用没有任何指向值为null的数组的情况，该引用还在用于操作实体，则会出现这样的错误。
(2)ArrayIndexOutOfBoundsException: 5：操作数组数组时，访问到了数组中不存在的角标，则会出现这样的错误。
内存结构：
java程序在运行时，需要在内存中分配空间。为了提高运算效率，又对空间进行了不同区域的划分，因为每一片区域都有特定的功能和内存管理方式不同。
栈内存：
用于存储局部变量，当数据使用完，所占空间会自动释放。
堆内存：
数组和对象，通过new建立的实例都存放在堆内存中。
每个实体都有内存地址值
实体中的变量都默认初始化值
实体不在被使用，会在不确定的时间内被垃圾回收机制回收。
方法区，本地方法区，寄存器
***栈内存和堆内存详解***
【2016.7.23】
**数组的操作：（**）
(一)：获取数组中的元素。通常会用到遍历。
可以用到for循环来遍历数组
数组中有一个属性可以直接获取到数组元素个数。length
使用方法：数组名称.length =
***遍历数组实例***
（二）：获取数组的最大值和最小值
获取最值需要进行比较。并通过条件赋值。
***数组获取最值实例***
（三）：对数组中的元素进行排序
选择排序：
 
冒泡排序：相邻的两个元素进行比较，如果符合条件换位。
第一圈：最后一位出现最值。
每比较一圈，数组元素少一个。


***数组的排序实例***
【2016.7.24】
数组：折半查找（**）
折半查找也称为二分法查找，前提是查找数组是一个有序数组。
***数组折半查找实例***

数组：十进制——》》二进制（**）
除2模2.
存储数据的容器
StringBuffer sb = new StringBubffer();
容器提供的添加功能（方法）：
sb.append();
容器提供的反转功能（方法）
sb.reverse()
**StringBuffer容器实例**
数组：十进制——》》十六进制（*****）
在位运算知识点中有提到相关内容，但是在这里的右移将使用无符号右移（>>>）,
(char)
十六进制，0-9，A-F，满16进1，用0x开头，所以这个公式可以将大于九的数转换为A-F，例如，如果十六进制所得最后一位的十进制表示为12，则其公式为（char）（12-10+'A'）=C
***十六进制转换实例***
数组：查表法（十进制--》十六进制） 
查表法：将所有的元素临时存储起来，建立对应关系
利用十六进制中的元素与0-15的对应关系，联想到数组中元素与元素角标的对应关系，建立数组容器，在每次 & 15后的值作为索引去查建立好的表，就可以找到对应对的元素。这样比（-10+'A'）要易懂且方便
0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F == 十六进制中的元素
0  1  2  3  4  5  6  7  8  9  10 11  12  13 14 15
最后可以和之前的十六进制换一样，但是为了把让结果正过来打印，
利用了StringBuffer容器以及reverse()方法，那么怎样使用现有知识来实现与此一样的功能呢？
我们发现StringBuffer是一个容器，而数组也是一个容器，想方法将数组实现此功能。
数组：查表法（十进制--》二进制）
其方法和以上一致，只是二进制数的位数最大为32，十六进制位数为15.且二进制中的元素就只有两位。{'0','1'},且在位运算时每次只偏移一位。

注意：在多次练习中，发现自己一个严重的基本问题，就是在定义变量时经常把变量类型写在前面就直接写变量名和赋值，有时也会忘记括号后的分分号。牢记牢记牢记
***数组查表法进制转换实例***
数组：进制转换优化
在十进制转换为十六进制的查表法中，发现十六进制的所有元素，包含了二进制的元素，八进制的元素，还有十进制的元素，所以，我们可以提取共性之处进行封装，封装为功能加以调用，则可以实现多种进制的转换而节省代码量。
***查表法结合函数提取共性优化程序实例***
二维数组[][]：
格式一：int[][] arr = new int[3][2];
定义了名称为arr的二维数组
二维数组中有三个一维数组
每一个一维数组中有两个元素
一维数组的名称分别为arr[0],arr[1],arr[2]
给第一个一维数组1脚标位赋值为78写法是：arr[0][1]=78;
格式二：int[][] arr = new int[3][];
二维数组中有三个一维数组
每个一维数组都是默认的初始化值null
可以对这三个一维数组分别进行初始化，如下
  arr[0] = new int[3]
  arr[1] = new int[1]
  arr[3] = new int[2]

面向对象：
面向对象概念
类与对象的关系
封装
构造函数
this关键字
static关键字
单例设计模式

--面向对象概念
面向对象是相对面向过程而言
面向对象和面向过程是一种思想
面向过程
    -强调的是功能行为
面向对象
    - 将功能封装进对象，强调具备了功能的对象
面向对象是基于面向过程的
举例：
公司员工招收程序员的实例：
公司领导为了解决业务更加的方便，面试程序员就是在找合适的对象，公司要开发很多软件，而公司领导如果要去自己开发会很麻烦，而程序员就具备这样的功能，只需程序员去开发，结果返回给公司就行。
“万物皆对象”抽象
面试理解面向对象问题
分析对象：名词提炼法
人开门：人，门》》对象》》门

--类与对象的关系
面向对象的三个特征：
封装
继承
多态
//以后的开发：其实就是找对象使用，没有对象，就创建一个对象
//找对象，建立对象，使用对象，维护对象

现实中的对象：张三，李四
想要描述这对象：就提取对象中共性内容，对具体抽象

映射到java中，描述就是class定义的类
具体对象就是对应java在堆内存中用new产生的实体，这个实体在堆内存中都有地址值，

类：就是对现实生活中事物的描述
对象：就是这类事物，实实在在存在的个体


--其实定义类，就是在描述事物，就是在定义属性和行为。
--属性和行为共同称为类中的成员（成员变量和成员方法（函数））

定义类：
class Sum{//定义一个类
int x = 1// 成员变量
int y = 2// 成员变量
void sum(){//成员函数
   System.out.println(x+y);
 }
}
//主函数中产生新对象，主函数就作为程序的入口，调用各种类产生新对象
//通过new操作符来完成产生新对象，并在堆内存中产生一个实体
//新对象所具有的属性在默认情况下是有默认值的，未赋值则为null或0等
class HelloWorld{
   public static void main(String[] args){
    //z1就是一个类类型变量，记住类类型变量指向对象，在内存中的地址值是相同的，z1是对象的引用
    Sum z1 = new Sum();
    //改变对象的默认属性值，重新赋值
    z1.x = 3
    z1.y = 5
    z1.run();//调用类中的方法
   new Sum().run();//产生匿名对象
  }
}
匿名对象：
new Sum().run();//产生匿名对象
等价于以下：
Sum z1 = new Sum();
z1.run();
--匿名对象使用方式一：当对对象的方法只调用一次时，可以用匿名对象来完成，这样比较简化
--如果对一个对象进行多个成员调用，必须给这个对象起个名字
--匿名对象使用方法二：可以将匿名对象作为实际参数进行传递
--成员变量和局部变量的区别以及作用范围：
成员变量作用于整个类中
局部变量作用于函数中，或者语句中
--两者在内存中的位置：
成员变量：在堆内存中，因为对象的存在，才在内存中存在
局部变量：存在栈内存中

一个程序有一般只有一个主函数，多个类。
---封装
封装：隐藏对象的属性和实现细节，仅对外提供公共访问方式
好处：
将变化隔离
便于使用
提高复用性
提高安全性
原则：
将不需要对外提供的内容都隐藏起来
将属性隐藏起来，提供公共方法对其访问

类和方法都是封装体，方法是最小的封装体
封装（private）：
--一个成员变量通常都会对应两个访问方式，而这两个方式也通常使用两个对外方法来提供，对于这两个方法的命名规范，通常是一个设置（setXXX）--》返回值类型一般为void，一个获取（getXXX）--》返回值一般为获取的变量值类型。
--如果在程序中出现以上两种命名，则有可能在这个类中存在一个私有的变量
--之所以提供公共访问方法，就是因为可以在方法中加入逻辑判断等语句。对访问的数据进行操作，提高代码的健壮性

private：私有（最小权限），权限修饰符：用于修饰类中的成员（成员变量，成员函数）
私有修饰后的成员只有在本类中有效，外界无法访问
注意：私有只是封装的一种表现形式。

class Person{
    //如果在定义的类中修饰这个成员变量，则这个变量只能在这个类中访问,权限修饰以后，提高了安全性
    private int age;
    //提供公共访问方法：
    public void setAge(int a){ //设置
        if(a>0 && a<130)
        age = a;
        speak();
        else{
        System.out.println("非法数据");
        }
    }
    public void getAge(){//获取
        return age;
    }
    void speak(){
    System.out.println("age="+age);
    }
}
***private关键字实例***
构造函数：
特点：
函数名与类名相同
不用定义返回值类型
不用写return语句
对象一建立就会调用与之对应的构造函数
作用：
用于对象初始化。如：一出生就哭
构造函数的小细节：
如果一个类中没有定义构造函数时，那么系统会默认给该类加入一个空参数的构造函数。

构造函数也具有函数的相关特性，重载

++一个类可以产生不同的对象，这些不同的对象都有与之对应的构造函数，也就有了不同的初始化方式

构造函数和一般函数的区别：
1.构造函数和一般函数在写法上有不同
2.在运行上不同
2.1.构造函数是在对象一建立就运行，给对象初始化。
2.2.而一般方法是对象调用才执行是给对象添加对象具备的功能
2.3.一个对象建立，构造函数只运行一次。
2.4.而一般方法可以被该对象调用多次。
2.5.方法一般被对象调用

什么时候定义构造函数？
当分析事物时，该事物存在具备一些特性或者行为，那么将这些内容定义在构造函数中。

构造函数也可以被私有化(private)，但是如果私有化后就无法新建对象

注意：
一个类中默认会有一个空参数的构造函数，这个默认的构造函数的权限和所属类一致。
如果类被public修饰，那么默认的构造函数，也带public修饰符
如果类没有被public修饰，那么默认的构造函数，也没有public修饰。

默认构造函数的权限是随着类的变化而变化的。

构造代码块：
作用：
给对象进行初始化
特点：
对象一建立就运行，而且优先于构造函数执行
构造代码块中定义的是不同的对象的共性初始化内容
和构造函数的区别：
构造代码块是给所有对象进行统一初始化
构造函数是给对应的对象进行初始化
***构造函数与构造代码块实例***

this关键字：
1.--区分局部变量和成员变量同名的情况
this为什么可以解决这个问题？
this到底代表的是什么

this：代表本类的对象，到底代表哪一个呢？
  this代表它所在函数所属对象的引用。
  简单的说：哪个对象在调用this所在的函数，this就代表哪个对象。

this关键字的应用：
当定义类中功能时，该函数内部要用到调用该函数的对象时，这时用this来表示。
但凡本类方法内部使用了本类对象，都用this表示。

看到this就要想到它是代表一个对象的引用。

2.--this调用构造方法，在本类中应用，且只能使用this
格式：this( )；
例：
class Person{
    private String name;
    private int age;
    public Person(){}
    public Person(String name){
        this(); // 调用无参构造方法    
        this.name = name;
    }
    public Person(String name,int age){
        this(name);// 调用一个有参构造方法
        //this.name = name;
        this.age = age;
    }
    public void printParam(){
        System.out.println(name+"\t"+age);
    }
}

注意：this()只能写在调用的构造函数第一行。否则编译失败。因为this调用的构造函数也是一个初始化动作，必须让所调用的先初始化，再进行调用者的方法的初始化。

一个类中可以给对象提供多种初始化方式，但是可以只做一个入口给程序初始化，可以用this调用构造函数的方法
***this关键字的应用实例***
***this关键字调用构造函数***

static（静态）关键字：
---用于修饰成员（成员变量和成员函数）
---普通成员变量也叫做实例变量，随着对象的存在而加载，静态的修饰的成员变量也叫类变量，随着类的加载而加载，随着类的消失而消失，生命周期比普通成员变量长
被修饰后的成员具备以下特点（内存）：
---随着类的加载而加载，随着类的消失而消失，生命周期长
---优先于对象存在
---被所有对象共享
---可以直接被类名调用（类名.静态成员）
---在内存中在方法区（共享区，数据区）存在

使用注意：
---静态方法只能访问静态成员
-----非静态方法既可以访问静态也可以访问非静态
---静态方法中不可以写this，super关键字
-----因为静态优先于对象存在，所以静态方法中不可以出现this。
---主函数是静态的

在分析对象时，分清特有属性和共享属性，共享属性就可以将其修饰为静态，这样既节省内存


实例变量和类变量的区别：
普通成员变量也叫做实例变量，静态的修饰的成员变量也叫类变量
1.存放位置：
    类变量随着类的加载而存在于方法区中
    实例变量随着对象的建立而存在于堆内存中。
2.生命周期：
    类变量生命周期最长，随着类的消失而消失。
    实例变量生命周期随对象消失而消失

静态有利有弊：
利处：对对象的共享数据进行单独空间的存储，节省空间。没有必要每个对象都存储一份。
弊端：生命周期长，，访问出现局限性。（只能访问静态）
***static关键字应用实例***

主函数（main方法，主方法）
主函数的定义：
public: 代表着该函数访问权限最大的
static： 静态方法，代表主函数随着类的加载就已经存在了
void：主函数是没有具体返回值，因为调用者是虚拟机（JVM）
main：这不是关键字，但是是一个特殊的单词，它可以被JVM(虚拟机)识别
(String[] arr): 函数的参数，参数类型是一个数组，该数组中的元素是字符串，参数名称是可以更改的，但一般情况下参数名写成args，它是arguments（参数）的简写。
***主函数的特性验证***
主函数的格式是固定的：JVM(虚拟机)识别
在程序运行时，JVM在调用主函数时，向主函数里传入一个长度为0的数组，

JVM在调用主函数时，传入的是new String[0];

何时使用静态：
要从两个方面下手：
因为静态修饰的内容有成员变量和函数
什么时候定义静态变量（类）呢？
当对象中的出现共享数据时，该数据被静态所修饰。并存放于方法区
对象中的特有数据要定义成非静态存在于堆内存中。

什么时候定义静态函数呢？
当功能内部没有访问到非静态数据（对象的特有数据）
那么该功能可以定义为静态的。

静态的应用--工具类：
每一个应用程序中都有共性的功能，可以将这些功能进行抽取，独立封装，以便复用。
在封装时，要清楚那些方法是对外提供的，哪些是是无需对外提供的，无需对外提供的就私有化（private），对外提供就公有（public）；清楚在各个方法中，是否引用了对象中的特有成员属性数据，如果没有就静态（static）修饰。考虑是否需要建立新对象。
***static-工具类实例***

帮助文档javadoc的制作：
文档注释。它以“/**”开始，以“*/”标志结束。文档注释提供将程序信息嵌入到程序中的功能。开发者可以使用 javadoc 工具将信息取出，然后转换为 HTML 文件。文档注释提供了编写程序文档的便利方式。

在类前，方法前，用文档注释写下内容，并用特殊的标识，就可被javadoc所识,生成javadoc
基本标识：

类前的描述（例）：
对类的描述信息，写在类前
@author(作者) 张三
@version v1.0

方法前描述（例）
对类的描述
@param（参数） x int数据
return（返回值）

在dos下生成javadoc的命令：
javadoc -d 存放位置 -author(作者) -version（版本）文件名.java

静态代码块：
格式：
static{
    静态代码块中的执行语句。
}
特点：
随着类的加载而执行，只执行一次。并优先于主函数执行
用于给类进行初始化的

类是否加载，用静态代码块就可以验证。

对象的初始化过程
现假设有一个类Person，类中有一段静态代码块，类中有name,age,country三个属性，其中country为（static）静态修饰的成员变量(类变量)，类中有一段构造代码块，类中有多个构造函数。

现在在主函数中建立一个Person对象：
Person p = new Person("zhangsan",21);
这个建立对象的语句在内存中的初始化顺序如下：
因为new用到了Person.class，所以会先找到Person.class文件并加载到内存中。
执行该类中的 static（静态）代码块 ，如果有的话，给Person.class类进行初始化。
在堆内存中开辟空间，分配内存地址。
在堆内存中建立对象的特有属性。并进行默认初始化。
对属性进行显示初始化。
对对象进行构造代码块初始化。
对对象进行对应的构造函数初始化。
将对象地址赋给栈内存中的p变量。
对象初始化完成。
图示：

注意：
栈内存中会先加载主函数，然后Person p的时候，就有一个变量p存在于栈内存。
类变量在这里没有画出，因为它随着类的加载就加载于“方法区”中。比对象还要早加载。
蓝色的静态代码块，不是在对象里加载而是在类加载的时候就已经加载了，为了体现流程把它写在了里面，望悉知！
对象调用成员过程：
现假设有一个类Person，类中有一段静态代码块，类中有name,age,country三个属性，其中country为String类型的（static）静态修饰的成员变量(类变量)且值为"CN"，类中有一段构造代码块，类中有多个构造方法，和其他成员方法。

现类中有非静态成员方法如下：
public void setName(String name){
    this.name = name;
}
现有静态方法如下：
public static void printCou(){
    System.out.println(country);
}

现在在主函数中建立一个Person对象并且调用setName方法：
Person p = new Person("zhangsan",21);
p.setName = ("lisi");

说明：
在类中，类变量，也就是静态修饰的变量，还有所有的方法和方法体，包括静态方法和非静态方法都随着类的加载而加载在方法区中，所以以上成员都是优先于对象存在的。
（12）对象在调用成员方法（非静态）setName时，因为有局部变量name的存在，首先在栈内存中开辟了一个空间，this作为变量p的引用（13）而指向（14）堆内存中的对象。
方法一调用，局部变量就会得到值“lisi”，name ="lisi".
（15）再执行方法里的语句，就知道局部变量name赋值的是p这个对象中的name
（16）将值赋给对象中的name,执行完成这个方法在栈内存中自动释放。
图中椭圆圈中的数字顺序，则是一个对象建立所有的加载顺序。
​主函数>>加载类文件>>加载静态类变量和方法>>建立对象>>调用对象成员。

（面向对象）单例设计模式：
解决某一类问题最行之有效的方法。
java中有23中设计模式。

单例设计模式：
解决一个类在内存中只存在一个对象。
例：两个程序修改同一份配置文件。并且不管谁加载这个配置文件都是任意修改后的文件。

想要保证唯一：
1.为了避免其他程序过多的建立对象，先禁止其他程序建立该类对象
2.还为了让其他程序可以访问到该类对象，只好在本类，自定义一个对象
3.为了方便其他程序对自定义对象的访问，可以对外提供一些访问方式。

如何用代码体现?
1.将构造函数私有化。
2.在类中创建一个本类对象并静态
3.提供一个方法，可以获取到该对象。
实现方式一（饿汉式）：
在类一加载时，就已经创建对象，称为“饿汉式”
class Single {
    private String Test = "我是单例设计模式的测试";
    public void setTest(String Test){
        this.Test = Test;
    }
    public String getTest(){
        return Test;
    }
    private Single(){}
    // 创建本类对象，其他程序也可访问到该类对象并私有化对象，
    // 因为调用方法就两种方式，一个类名调用，一个对象调用，
    // 既然外界都无法创建对象，我们就以类名调用，所以将对象静态修饰
    private static Single s = new Single();
    public static Single getInstance() {
        return s;
    }
}
实现方式二（懒汉式）：
对象是方法被调用时，才初始化，也叫做对象的延时加载，故称为“懒汉式”
class Single1 { //
    private static Single s = null;
    private Single(){}
    public static Single getInstance() {
        if (s=null) {
            s = new Single();
        }
        return s;
    }
}
拓展：cup处理程序时，多个程序运行时cpu在很快的在之间切换，所以多核提高运行速度
弊端：如果多个程序同时调用返回方法，就有可能使对象不唯一

解决方案：
1.在方法中添加synchronized（同步）关键字，但是程序的效率会大大降低
2.多重判断(涉及多线程)：
if (s=null){
    synchronized(Single.class) {
        if (s=null) {
           s = new Single();
        }
        }
      return s;
 }
一般开发时，如果用到单例设计模式，会使用饿汉式，安全高效
***单例设计模式详解***
对于事物怎么描述，还是怎么描述，
当需要将该类事物的对象保证在内存中唯一时，就将以上三步加上即可。

继承（extends）
1.继承的概述
2.继承的特点
3.super关键字
4.函数覆盖
5.子类的实例化过程
6.final关键字

1.继承概述：
类的继承可以以既有的类为基础，进而派生出新的类。
举例：
现有一Person类，具备name和age两个属性，
Student类，具备name,age,school三个属性，
Worker类，具备name，age，company三个属性，
我们发现在worker和Student两个类中，name和age两个属性，在Person类中具有，这样，就有了继承的存在。

继承的格式是：class 子类 extends 父类
***继承初识实例***

2.继承的特点：
1.提高里代码的复用性。
2.让类与类之间产生关系，有里这个关系，才有了多态。

注意：
1.千万不要为了获取其他类的功能，简化代码而继承。必须是类与类之间有所属关系才可继承
2.先有父类，再有子类。
3.java语言中：java只支持单继承，不支持多继承。

否则容易带来安全隐患：当多个父类中定义了相同功能，当功能内容不同时，子类对象不确定要运行哪一个。
4.java支持多层继承，也就是一个“继承体系”


如何使用一个继承体系中的功能？
想要使用体系，先查阅体系父类的描述，因为父类中定义的是该体系中的共性功能。通过了解共性功能，就可以知道该体系的基本功能。那么这个体系已经可以基本使用了。

那么在具体调用时，要创建最子类的对象，为什么？
1.因为有可能父类不可创建对象
2.创建子类对象可以使用更多的功能，包括基本的也包括特有的。

总结：查阅父类功能，创建子类对象使用功能。

聚集关系：
继承：B是A的一种
聚集：A里有B
聚合：B是A的组成成员
组合：
3.super关键字
子父类中变量的特点：
1.变量：
如果子类中出现非私有的同名成员变量时（几乎不会遇到），子类要访问本类中的变量，用this，子类要访问父类中的同名变量，用super。

super的使用和this的使用基本一致。
this代表的是本类对象的引用。
super代表的是父类对象的引用。
***super关键字及子父类变量特点实例***

子父类中函数的特点--覆盖（重写）
当子类出现和父类一模一样的函数时，当子类对象调用该函数，会运行子类函数的内容。
如同父类被覆盖一样，也称重写。

应用：
当子类继承父类，沿袭里父类的功能到子类中，
但是子类虽具备该功能，但是功能的内容却和父类不一致，
这时，没有必要定义新功能，而是使用函数的覆盖特性，保留父类的功能定义，并重写功能内容

注意：
1.子类覆盖（重写）父类，必须保证子类权限大于等于父类权限，才可以覆盖（重写），否则编译失败
2.静态只能覆盖静态。
3.重载：只看同名函数的参数列表
4.重写：子父类方法要一模一样
***函数的重写实例***

子父类中构造函数的特点--子类实例化过程
在对子类对象进行初始化时，父类的构造函数也会运行，那是因为子类的构造函数默认第一行有一条隐示的语句 super();

super():会访问父类中空参数的构造函数。而且子类中所有的构造函数默认第一行都是 super();

为什么子类一定要访问父类中的构造函数？
因为父类中的数据子类可以直接获取。所以子类对象在建立时，需要首先查看父类是如何对这些数据进行初始化的。
所以子类在对象初始化时，首先要访问父类的构造函数。

如果要访问父类中指定的构造函数，可以通过手动定义super语句的方式来指定：super(x);

注意：super语句一定要定义在子类构造函数的第一行。

子类的实例化过程：
结论：
1.子类的所有构造函数，默认都会访问父类中空参数的构造函数。因为子类每一个构造函数的第一行都有隐示的语句super();
2.当父类中没有空参数的构造函数时，子类必须手动通过super语句形式来指定要访问的父类中的构造函数。
3.当人子类的构造函数第一行也可以手动指定this语句来访问本类中的构造函数，但是子类中至少会有一个构造函数会访问父类的构造函数。
***子父类构造函数特点子类对象的初始化过程***

final关键字
final：最终。最为一个修饰符
1.可以修饰类，函数，变量。
2.被final修饰的类不可被继承。为了避免被继承，被子类重写功能。
3.被final修饰的方法不可以被重写。
4.被final修饰的变量是一个常量只能赋值一次，既可以修饰成员变量也可以修饰成员变量，当描述事物时，一些数据的出现值是固定的，那么这时为了增强阅读性，都给这一值起名。
5.内部类定义在类中的局部位置上时，只能访问该局部被final修饰的局部变量。
***final关键字的应用实例***

面向对象--抽象类
关键字（abstract）
当多个类中出现相同功能，但是功能主体不同，就可以进行向上抽取，这时，只抽取功能定义，而不抽取功能主体。
抽象：看不懂

抽象类的特点：
1.抽象方法一定在抽象类中。
2.抽象方法和抽象类都必须被abstract关键字修饰。
3.抽象类不可用new创建对象。因为调用抽象方法没有意义。
4.抽象中的抽象方法要被使用，必须由子类复写其所有的抽象方法后，建立子类对象调用，如果子类只覆盖类部分抽象方法，那么该子类还是一个抽象类。
